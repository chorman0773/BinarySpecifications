# ShadeNBT Version 1.4 Draft

Expected Release Date: 2020-01

Description: ShadeNBT is a modification on the standard Named Binary Tag Specification, created for the Game Minecraft. 
The format is used to protection against corrupt game files, as well as to ensure Binary Version Compatibility. 
The format contains a 7-byte header, which declares that the file is a ShadeNBT File, followed by a well-formed uncompressed NBT File, that contains a single, nameless compound tag. 

A Variation of this Specification, known as CryptoShade, provides Strong, Password-based Encryption of the enclosed NBT File and MAY additionally be supported by conforming implementations. 


## References ##
This document references a modification of the Named Binary Tag Specification, created by Markus Person for the Game Minecraft. 
An up to date version of the NBT Specification can be found [here](https://wiki.vg/nbt). 

All Binary Datatypes are written and read according to the LCLib Binary Data IO Specification. The LCLib Binary Data IO Specification can be found [here](https://github.com/LightningCreations/lclib/blob/specification/Specification/BinaryDataIO.md). 

## Changes from 1.3 ##

An additional tag, `TAG_Ref` is added, to allow parts of a ShadeNBT file to reference another part of the file.

## Rejecting Files ##

For various reasons implementations MUST, SHOULD, or MAY reject a ShadeNBT File. 
If a user attempts to load a file which is rejected, an error MUST be reported to the user. A rejected file MUST NOT be loaded. 
Implementations MUST NOT create a ShadeNBT File that it would reject. 

## Structure of a Shade Save File ##

### Header ###

Each Shade file shall contain a header, which is defined by the following structure:

```
shade_head{
	Byte magic[4];
	Version ver;
	Byte shadeFlags;
}
```

magic MUST be exactly the bytes [AD 4E 42 54], or the file MUST be rejected.

ver encodes the version of the ShadeNBT Specification which the file was created in. 
This is encoded in the LCLib Versioning format, where the major value indicates the major version-1, and the minor value indicates the minor version. 
The current version of the specification is 1.3, and therefore the version for a file created in this version is [00 04]. 


Conforming Implementations MUST Document at least 1 supported version, and support all versions with the same major version number and a lesser or equal minor version number as each of those supported versions. 

Conforming Implementations SHOULD support the latest version of the Specification released at the time the Implementation was created or updated. 

Implementations MUST reject any file that indicates an unsupported version, or any version that has not been released. 

If ver indicates the version 1.1 or less, then shadeFlags does not exist and the file MUST be read in Big Endian Byte Order Mode. Otherwise, shadeFlags indicates a series of flags. 

If shadeFlags has the most significant bit set (0x80), then the file MUST be read in Little Endian Byte Order Mode. Otherwise it MUST be read in Big Endian Mode. 

If shadeFlags has its next most significant bit set (0x40) , and the Indicated version is 1.3 or greater, then the next 32 bytes is a SHA-256 hash of the content of the `Compound`. If the hash of the `Compound` does not match these bytes, the file MUST be rejected. If this bit is set and the version indicated is 1.2 or less, then the file MUST be rejected. This bit SHOULD be set in most ShadeNBT files for version 1.3. 

If shadeFlags has its 3rd most significant bit set (0x20), and the indicated version is 1.3 or later, then NaN values may be written in float, double, float array, and double array tags. A file with this flag set MAY be rejected by an implementation. This flag SHOULD NOT be set unless a NaN value appears in one of those tags. If this bit is set and the version indicated is 1.2 or less, then the file MUST be rejected. 

If any other bits are set in shadeFlags, the file MUST be rejected. 


### NBT Data ###

NBT Data Tags are encoded using LCLib Binary Data IO Format, in Big Endian. There are various tags which indicate the type of data stored. 

```
NBT_Tag{
	Byte tag;
	String name;
	union TAG_Payload{
		Byte tag_byte;
		Short tag_short;
		Int tag_int;
		Long tag_long;
		Float tag_float;
		Double tag_double;
		ByteArray{
			Int len;
			Byte payload[len];
		} tag_byte_array;
		string tag_string;
		List{
			Byte listTagType;
			Int len;
			TAG_Payload[len];
		} tag_list;
		Compound{
			NBT_Tag tags[];
			Byte endTagType;
		} tag_compound;
		IntArray{
			Int len;
			Int payload[len];
		}tag_int_array;
		LongArray{
			Int len;
			Long payload[len];
		}tag_long_array;
		FloatArray{
			Int len;
			Float payload[len];
		}tag_float_array;
		DoubleArray{
			Int len;
			Double payload[len];
		}tag_double_array;
		UUID tag_uuid;
		RefPath tag_ref;
	}payload;
}
```

Where `tag` determines the payload, and shall be either 0x01 (`tag_byte`), 0x02 (`tag_short`), 0x03 (`tag_int`), 0x04 (`tag_long`), 0x05 (`tag_float`), 0x06 (`tag_double`), 0x07 (`tag_byte_array`), 0x08 (`tag_string`), 0x09 (`tag_list`), 0x0a (`tag_compound`), 0x0b (`tag_int_array`), 0x0c (`tag_long_array`), 0x0d (`tag_float_array`), 0x0e (`tag_double_array`), 0x0f (`tag_uuid`), 0x10 (`tag_ref`). 

If any other tag is read, except for `tag` 0 inside of a `tag_compound`, the file MUST be rejected. 
If the tag is 0x10 and the version indicated is 1.3 or lower, then the file MUST be rejected. 
If the tag is 0x0d, 0x0e, or 0x0f and the version indicated is 1.2 or lower, then the file MUST be rejected.
If the tag is 0x0c and the version indicated is 1.0, then the file MUST be rejected.

In Compound `tags` shall continue until the `tag` read is 0x00.

In List, `listTagType` shall be any valid value for `tag`, or 0x00 if `len` is 0. If it is not, then the file MUST be rejected. 

Every ShadeNBT File shall contain a `Compound` Payload following the header. This Compound must contain a single nameless NBT Tag which is a `tag_compound`. This Compound is refered to as the Top Level Compound.

There may be any number of zero bytes following the `Compound` Payload in a ShadeNBT File. 

### RefPath Struct

A `RefPath` is formed recursively, and defines a sequence from some point as to construct the remaining path.

The `RefPath` structure is defined as follows:

```
struct RefPath{
	u8 pathKind;
	union{
		EMPTY PathEntry_terminal;
		EMPTY PathEntry_deref;
		i16 PathEntry_index;
		i32 PathEntry_windex;
		string PathEntry_tag;
		EMPTY PathEntry_rel;
		EMPTY PathEntry_parent;
		EMPTY PathEntry_current;
	};
};
```

Where `EMPTY` denotes entries which have no content, and each RefPath that is not a `PathEntry_terminal` is followed by an additional `RefPath` struct.

`pathKind` MUST be either 0 (`PathEntry_terminal`), 1 (`PathEntry_deref`), 2 (`PathEntry_index`), 3 (`PathEntry_windex`), 4 (`PathEntry_tag`), 5 (`PathEntry_rel`), 6 (`PathEntry_parent`), or 7 (`PathEntry_current`). 

Each Entry in a `RefPath` is interpreted as follows:
* If the Entry is a `PathEntry_terminal`, there MUST have been at least one previous entry that is not a `PathEntry_rel`. The `Tag_ref` refers to the tag which is derived from the complete path.
* If the First Entry is `PathEntry_rel`, then the path starts at the `Tag_compound` or `Tag_list` directly enclosing the `Tag_ref`, otherwise, it starts from the root compound (the unnamed, single compound which the file contains). There MUST NOT be any entry in a `RefPath` that is a `PathEntry_rel`, except for the first entry of that path.
* If the entry is `Path_current`, then the tag referred to by this entry is the one referred to by the path directly preceeding it. That is, `Path_current` is a no-op, except that it may be used in `RefPaths` which either refer to the directly enclosing tag, or the root tag (as paths have to have at least one entry that is not a terminal entry, or a relative entry). The presence of `Path_current` affects the length of the `RefPath`, which limits MAY be imposed upon. 
* If the entry is `Path_parent`, then the tag referred to by this entry is the parent of the tag referred to by the path directly preceeding it. In the special case that the tag previously referred is the root compound, `Path_parent` acts identically to `Path_current`. (Note that `Path_parent` is therefore analogous to the directory entry `..` in filesystems, though `Path_parent` may be applied to tags which cannot have any other children, such as `Tag_int`s. By the same reasoning `Path_current` is analogous to the directory entry `.`)
* If the entry is a `Path_index` or `Path_windex`, then the tag referred to by the path directly preceeding this entry MUST be a `Tag_list` or an array tag `a`, with length `l`. If a positive index `i` is used, the referenced entry is `a[i]`. If a negative index `i` is used, the referenced entry is `a[l-i]`. The index MUST lie within the interval `[0,l)`. (Note that a `Path_index` can be used in all cases with a `Tag_list`, as negative indexing can search elements outside of the positive index range. In the special case, where `l` is 65535 (the largest it can be), and only in this special case, `i` can be treated as unsigned and the same behavior is achieved). If `a` is an array tag (and not a list), then the path does not refer to any particular `tag` but the appropriate entry in `a`. This is due to the fact
* If the entry is a `Path_tag`, then the tag referred to by the path directly preceeding this entry MUST be a `Tag_compound`. The string used MUST be the name of a tag in that `Tag_compound`, and this entry refers to that tag. (Note that as End tags have no name, along with other restrictions, makes it impossible that a Path refer to a `Tag_end`. Having no name is not the same as having an empty name)
* If the entry is a `Path_deref`, then the tag referred to by the path directly preceeding this entry MUST be a `Tag_ref`. The `Path` prescribed by the `Tag_ref` is followed, and the tag referred to by this entry is the one referred to by the `Tag_ref`.

## Limits of the Implementation ##

Implementations may impose various limits upon Read ShadeNBT Files, including number of nested compound and list tags, and number of tags in a compound. 
Specifically, Implementions MUST support at least:
* 2^24 Tags in an array or compound
* 128 Total Nested list and compound tags, excluding the top level compound. 
* All UTF-8 Encoded Characters, which are require 3 bytes or less and no surrogate pairs. 
* Total of 2^32 bytes in the file. 
* A `RefPath` with a sequence of at most 128 entries, including a `PathEntry_terminal` entry.
* Up to 4 `PathEntry_deref`s resolved by a given `RefPath` entry.

Implementations MAY choose to reject any file which violates any of those above limits. 
